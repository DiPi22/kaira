
Kaira User Guide
=================

Kaira is as an open-source development environment for MPI (Message Passing
Interface) applications. We try to provide an unified environment for
activities for development: prototyping, programming, testing, debugging,
profiling, performance prediction and verification.

The main idea is to use visual models inspired by Coloured Petri Nets.
This model is designed to catch parallel aspects and communication inside of
developed application. We do not want to program applications completely in
a visual way, so our models can be enriched by any sequential C++ code.
With such model, a user can generate MPI applications, run simulations
or start a state-space analysis.

.Prerequisites
************
In this text, we assume that the reader is familiar with C++ and basic use
of Linux.
************

Installation
------------

.Quick answer for Debian based distributions if we want to install everything
************

  - Necessary packages

  $ apt-get install python-gtksourceview2 python-pyparsing g++ python-matplotlib

  - MPI implementation

  $ apt-get install mpich2

  - Libraries for verification subsystem

  $ apt-get install sparsehash libmhash-dev

  - Documentation

  $ apt-get install asciidoc

  - Configure Kaira

  $ ./waf configure

  - Build Kaira

  $ ./waf

  - Start Kaira

  $ ./start.sh

************

The following text covers the installation process in more detail.

Dependancies
~~~~~~~~~~~~

To run Kaira, you need the following software.

  - Linux
    * In general, Kaira should run on any UNIX-like systems where the
     following programs and libraries are available, but it was tested
      only on Linux systems.
  - Python 2.6 or 2.7
  - PyGTK
  - PyGTK sourceview2
  - pyparsing
  - g++
  - matplotlib

Optional dependancies:

  - MPI implementation (tested with: MPICH2, OpenMP, LAM)
  - sparsehash
  - mhash
  - asciidoc

MPI implementation is necessary if you want to build MPI applications.
Libraries 'sparsehash' and 'mhash' are used by the verification subsystem.
'asciidoc' is used to build HTML documentation.


.Installing packages in Debian based distributions
*****************************************************************************

We are going to install all necessary packages including optional.
We have chosen MPICH2 as MPI implementation.

------------------------------------------------------------------------------
apt-get install python-gtksourceview2 python-pyparsing g++ python-matplotlib

# MPI implementation
apt-get install mpich2

# Libraries for verification subsystem
apt-get install sparsehash libmhash-dev

# Documentation
apt-get install asciidoc
------------------------------------------------------------------------------

******************************************************************************

Building
~~~~~~~~

The first step is to download Kaira distribution from http://verif.cs.vsb.cz
and unpack it. Kaira is built by building tool 'waf'
(http://code.google.com/p/waf/). This tool is distributed together with Kaira.
The most common scenario (with all dependancies installed) is the following:

-------------------------------------------------------------------------------
cd /path/to/kaira
./waf configure             # Configuration step
./waf                       # Building step
-------------------------------------------------------------------------------

It's all. To check that Kaira works, you can start it by

-------------------------------------------------------------------------------
./start.sh
-------------------------------------------------------------------------------

More about configuration
^^^^^^^^^^^^^^^^^^^^^^^^

In the configuration step, additional parameters can be specified.
The basic ones are:

- '--disable-mpi' -- Kaira is built without MPI support
- '--disable-verif' -- Kaira is built without the verification support,
  i.e. libraries 'sparsehash' and 'libmhash' are not necessary
- '--disable-doc' -- Documentation is not generated
- '--icc' -- Intel's C++ complier is used to build Kaira instead of GCC.

For example, when we want to build Kaira without the support of MPI
and without generating documentation:

-------------------------------------------------------------------------------
./waf configure --disable-mpi --disable-doc  # Configuration step
./waf                                        # Building step
-------------------------------------------------------------------------------

The full list of parameters can be displayed by

-------------------------------------------------------------------------------
./waf configure --help
-------------------------------------------------------------------------------

The first program
-----------------

...

Syntax and semantics
--------------------

A program (project) in Kaira consists of 'visual model', 'sequential codes'
embeded into model and 'configuration'. This section contains description of
the visual model and its behaviour. The next section is about integration of
C++ codes, followed by the section covering configuration.

The visual model consists of the following items:

Places::
   Places serves as memory spaces
Transitions::
   Transitions represent computations
Edges::
   Edges define what data are needed to start a transtion and what is produced
   after its computation is finished
Init areas::
   Init areas serves to define processes where places are initialized

Places
~~~~~~

...


Transitions
~~~~~~~~~~~

...

Edges
~~~~~

There are two types of edges: 'Input edge' (from a place to a transition) and
'Output edge' (from a transition to a place). Semantics for them is described
in the next sections, but edges of both types have associated expressions with
the same structure. An edge expression consists of three parts:
'configurations', 'token-expressions' and 'target'.
The syntax in EBNF is the following:

--------------------------
edge-exp ::= [ `[', <configurations>, `]' ], [ <token-expressions> ], [ `@', <target> ] ;
configurations ::= { <configuration> } ;
configuration ::= identifier, [ `(', CPP-EXP, `)' ] ;
token-expressions ::= CPP-EXPR, { `;', CPP-EXPR } ;
target ::= CPP-EXPR
identifier ::= { letter or underscope } ;
--------------------------

Examples of valid edge expressions:

--------------------------
x + 1
10;30;40@x*2
[bulk] y
[if(x>2), multicast] x1; x2@where
--------------------------

Input edges
~~~~~~~~~~~

An 'input edge' is an edge from a place to a transition. Basic properties are:

  - There can be at most one arc between each place and transition
  - 'target' is not allowed
  - allowed configurations: 'bulk', 'guard(CPP-EXPR)', 'origin'
  - 'token-expressions' or 'configurations' has to be nonempty

The most common case is an edge without configurations, hence there are only
token-expressions.

--------------------------
expr1; expr2; ... exprN
--------------------------

In this case the the transition of the arc can be fired under binding *B* only
if there is at least *N* tokens in the place of the and first token in the
place's queue is equal to +eval(expr1, B)+, the second token is equal to
+eval(expr2, B)+, ... .

Output edges
~~~~~~~~~~~~

An 'output edge' is an edge from a place to a transition. Basic properties are:

  - There can be an arbitrary number of edges between each place and transition
  - 'target' is allowed
  - allowed configurations: 'bulk', 'if(CPP-EXPR)', 'multicast'
  - 'token-expressions' has to be nonempty.

Init areas
~~~~~~~~~~

...

Integration of C++ code
-----------------------

Project configuration
---------------------

Simulation
----------


Generating applications
-----------------------

Kaira generates the following application from a project:

release ::
traced ::
statespace ::
simulation :: Only for the internal usage by simulator, it is not inteded to be manually run by the user.


Tracing
-------



State space analysis
--------------------



Libraries
---------



Appendix
--------

Arguments of generated programs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-p *NAME=VALUE* :: Set the project parameter *NAME*
-t *N* --threads=*N* :: Set the number of threads per each process
-r *N* :: Set the number of processes
    (only in threads version;
     in MPI version is done through the parameter of 'mpirun')
-h --help :: Print the description of project parameters
-s *PORT* :: The application listens on defined *PORT*. *PORT* can be 'auto',
    then application chooses some free port and print it on stdout as
    the first line.
-b :: Block the application immediately after its initialization and
      wait for the first connection via port defined by -s argument.
-S :: Sequential mode. The application runs sequentially independently on
     number of processes or threads.
-T *SIZE* :: Enables tracelogging with the in-memory buffer of *SIZE* bytes for
    each process; The following suffixes can be used for in *SIZE*: K, M or G.
