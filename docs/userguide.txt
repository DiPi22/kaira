
Kaira User Guide
=================

Kaira is as an open-source development environment for MPI (Message Passing
Interface) applications. We try to provide an unified environment for
activities for development: prototyping, programming, testing, debugging,
profiling, performance prediction and verification.

The main idea is to use visual models inspired by Coloured Petri Nets.
This model is designed to catch parallel aspects and communication inside of
the developed application. We do not want to program applications completely
in a visual way, so our models can be enriched by any sequential C++ code.
With such model, a user can generate MPI applications, run simulations
or start a state-space analysis.

.Prerequisites
************
In this text, we assume that the reader is familiar with C++ and basic use
of Linux.
************

Installation
------------

.Instructions for Debian based distributions
************

These steps describe how to install the full version of Kaira.
How to disable some of subsystems is described below.

  - Installation of necessary packages

  $ apt-get install python-gtksourceview2 python-pyparsing g++ python-matplotlib

  - Installation of MPI implementation

  $ apt-get install mpich2

  - Libraries for verification subsystem

  $ apt-get install sparsehash libmhash-dev

  - Documentation

  $ apt-get install asciidoc

  - Configure Kaira

  $ ./waf configure

  - Build Kaira

  $ ./waf

  - Start Kaira

  $ ./start.sh

************


The following text covers the installation process in more detail.

Dependencies
~~~~~~~~~~~~

To run Kaira, you need the following software.

  - Linux
    * In general, Kaira should run on any UNIX-like systems where the
     following programs and libraries are available, but it was tested
      only on Linux systems.
  - Python 2.6 or 2.7
  - PyGTK
  - PyGTK sourceview2
  - pyparsing
  - g++
  - matplotlib

Optional dependencies:

  - MPI implementation (tested with: MPICH2, OpenMP, LAM)
  - sparsehash
  - mhash
  - asciidoc

MPI implementation is necessary if you want to build MPI applications.
Libraries 'sparsehash' and 'mhash' are used by the verification subsystem.
'asciidoc' is used to build HTML documentation.


Building
~~~~~~~~

The first step is to download Kaira distribution from http://verif.cs.vsb.cz
and unpack it. Kaira is built by building tool 'waf'
(http://code.google.com/p/waf/). This tool is distributed together with Kaira.
The most common scenario (with all dependancies installed) is the following:

-------------------------------------------------------------------------------
cd /path/to/kaira
./waf configure             # Configuration step
./waf                       # Building step
-------------------------------------------------------------------------------

It's all. To check that Kaira works, you can start it by

-------------------------------------------------------------------------------
./start.sh
-------------------------------------------------------------------------------

More about configuration
^^^^^^^^^^^^^^^^^^^^^^^^

In the configuration step, additional parameters can be specified.
The basic ones are:

- '--disable-mpi' -- Kaira is built without MPI support
- '--disable-verif' -- Kaira is built without the verification support,
  i.e. libraries 'sparsehash' and 'libmhash' are not necessary
- '--disable-doc' -- Documentation is not generated
- '--icc' -- Intel's C++ complier is used to build Kaira instead of GCC.

For example, when we want to build Kaira without the support of MPI
and without generating documentation:

-------------------------------------------------------------------------------
./waf configure --disable-mpi --disable-doc  # Configuration step
./waf                                        # Building step
-------------------------------------------------------------------------------

The full list of parameters can be displayed by

-------------------------------------------------------------------------------
./waf configure --help
-------------------------------------------------------------------------------

The first program
-----------------

...


Syntax and semantics
--------------------

A program (project) in Kaira consists of 'visual model', 'sequential codes'
embedded into model and 'configuration'. This section contains the description
of the visual model and its behavior. The next section is about integration of
C++ codes, followed by the section covering the configuration.

The visual model consists of the following items:

Places::
   Places serve as memory spaces
Transitions::
   Transitions represent computations
Edges::
   Edges define what data are needed to start a transition and what is produced
   after its computation is finished
Init areas::
   Init areas serve to define processes where places are initialized

Places
~~~~~~

The places serve as memory spaces for the program. Values stored in places are
called 'tokens'. Places works as queues so they remember order of tokens using
First-In-First-Out access.
(In this aspect, our model diverges from Colored Petri nets, where tokens are
stored in multisets, i.e. there is no order of tokens).

Each place has the following properties:

Name::
    An arbitrary string to describe the place with no actual meaning.
Type::
    Any C\++ type. Standard types (like 'int', 'std::vector') can be used
    directly; all supported types are listed in
    <<Types,Supported standard types>>. How to use user defined types is
    covered in Section Integration of C\++.
Init expression::
    An expression that initializes the place. In other words, it sets tokens of
    the place at the beginning of the program. It can be empty or can have
    the following two forms:
      - C++ expression of type 'std::vector<T>' where 'T' is the type of the
        place.
      - The list of C\++ expressions of the place's type. It has to
        starts with character '[' and ends with ']'. Each C++ expression has to
        be separated by ';'. Example: when the type of the place is 'double'
        we can use the expression as follows: '[1.0; 1.5; 2.8]'
Init code::
    A C++ code that allows generic place initialization.
    More in Section <<InitCode, Place init code>>.

Transitions
~~~~~~~~~~~

Transitions defines the behavior of the model. A program modelled in Kaira
evolves by firing transitions. A transition takes tokens from its input places,
computes new values and then put tokens into output places. What tokens are
needed to fire a transition and what tokens are produced when the transition
is fired is defined by 'edges'. Edges are the topic of the next section.
Here we describe properties of a transition not described by edges.

Name::
    An arbitrary string to describe the place with no actual meaning.
Guard expression::
    A boolean C\++ expression that can contain input variables. The guard
    expression has to be evaluated to 'true' to fire a transition.
Priority::
    An integer value that specifies the priority of the transition.
    When a transition is enabled then all transitions with lower priorities
    in the same process cannot be fired. If the priority is unspecified then
    the transition is considered as a transition with priority 0.
Fire code::
    A C++ code that is processed each time when the transition is fired.
    More in Section <<FireCode, Transition fire code>>.


The syntax of edges
~~~~~~~~~~~~~~~~~~~

For the following text we fix a transition, i.e. the following terms like
'input edge' are defined in context of this transition. Therefore each
transition can have different input edges.

There are two types of edges: 'Input edge' (from a place to a transition) and
'Output edge' (from a transition to a place). Semantics for them is described
in the next sections, but edges of both types have associated expressions with
the same structure. An edge expression consists of three parts:
'configurations', 'token-expressions' and 'target'.
The syntax in EBNF is the following:

--------------------------
edge-exp ::= [ `[', <configurations>, `]' ], [ <token-expressions> ], [ `@', <target> ] ;
configurations ::= { <configuration> } ;
configuration ::= identifier, [ `(', CPP-EXP, `)' ] ;
token-expressions ::= CPP-EXPR, { `;', CPP-EXPR } ;
target ::= CPP-EXPR
identifier ::= { letter or underscope } ;
--------------------------

Examples of valid edge expressions:

--------------------------
x + 1
10;30;40@x*2
[bulk] y
[if(x>2), multicast] x1; x2@where
--------------------------

An 'input edge' is an edge from a place to the transition.
Basic properties are:

  - There can be at most one arc between each place and the transition
  - 'target' is not allowed
  - allowed configurations: 'bulk', 'guard(CPP-EXPR)', 'origin'
  - 'token-expressions' or 'configurations' has to be nonempty

An 'output edge' is an edge from a place to the transition.
Basic properties are:

  - There can be an arbitrary number of edges between each place and transition
  - 'target' is allowed
  - allowed configurations: 'bulk', 'if(CPP-EXPR)', 'multicast'
  - 'token-expressions' has to be nonempty.

Edge related terms
^^^^^^^^^^^^^^^^^^

Input variable::
    A variable that appears in an expression on an input edge
    (in configurations and token-expressions).
Output variable::
    A variable that appears in an expression on an output edge
    (in configurations, token-expressions or target)
Transition variables::
    A union of input variables and output variables.

Semantics of transitions
~~~~~~~~~~~~~~~~~~~~~~~~

Here we discuss two topics: when the transition is 'enabled' and if
the transition enabled what happens when it is 'fired'.

Generally, input edges (together with the guard expression) control when
the transition is enabled. The most common case is an edge without
configurations, hence there are only token-expressions.

--------------------------
expr1; expr2; ... exprN
--------------------------

In this case the transition of the arc can be fired under binding *B* only
if there is at least *N* tokens in the place of the and first token in the
place's queue is equal to +eval(expr1, B)+, the second token is equal to
+eval(expr2, B)+, ... .

Evolution of the program
~~~~~~~~~~~~~~~~~~~~~~~~

...

Init areas
~~~~~~~~~~

...

Integration of C++ code
-----------------------

...

[[InitCode]]
Place init code
~~~~~~~~~~~~~~~

...

[[FireCode]]
Transition fire code
~~~~~~~~~~~~~~~~~~~~

...

Project configuration
---------------------

Simulation
----------


Generating applications
-----------------------

Kaira generates the following application from a project:

release ::
traced ::
statespace ::
simulation :: Only for the internal usage by simulator, it is not inteded to be manually run by the user.


Tracing
-------



State space analysis
--------------------



Libraries
---------



Appendix
--------

[[Types]]
Supported standard types
~~~~~~~~~~~~~~~~~~~~~~~~

The following types are natively supported by Kaira, so the user does not have
to write own 'token_name', 'pack' and 'unpack' functions.

  - bool
  - char
  - unsigned char
  - int
  - unsigned int
  - long
  - unsigned long
  - long long
  - unsigned long long
  - double
  - float
  - std::string
  - std::vector<T>
  - std::pair<T1, T2>
  - void* (Only numerical value of pointer is packed/unpacked)


Arguments of generated programs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-p *NAME=VALUE* :: Set the project parameter *NAME*
-t *N* --threads=*N* :: Set the number of threads per each process
-r *N* :: Set the number of processes
    (only in threads version;
     in MPI version is done through the parameter of 'mpirun')
-h --help :: Print the description of project parameters
-s *PORT* :: The application listens on defined *PORT*. *PORT* can be 'auto',
    then application chooses some free port and print it on stdout as
    the first line.
-b :: Block the application immediately after its initialization and
      wait for the first connection via port defined by -s argument.
-S :: Sequential mode. The application runs sequentially independently on
     number of processes or threads.
-T *SIZE* :: Enables tracelogging with the in-memory buffer of *SIZE* bytes for
    each process; The following suffixes can be used for in *SIZE*: K, M or G.
