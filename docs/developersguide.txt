
Kaira Developer's Guide
=======================

This guide serves as a manual for developers. There are described the basic
components of tool Kaira (http://verif.cs.vsb.cz/kaira).

User's extension
----------------

Kaira can be extended by user's extensions in form of operations. To an
operation can be looked upon similarly like to a mathematical function that
takes some arguments and produce one or more results. For these inputs
(arguments) and outputs (results) must be explicitly specified their data type.
Developers can use data types that were already implemented or define new one.

There are firstly described two basic objects that serves as an interface for
user's operations. Next follows an easy example of a user's data type
and an operation that use that. At the end is said how to these new components
integrate to Kaira.

Types
~~~~~
As it was mentioned, every operation must specify data types of their
inputs/outputs. For this purpose there is class +Type+ in module +datatypes+).
Every data type is consists of:

- a *name*,
- a *short name*,
- a *list of supported file types* (files extensions), and
- two dictionaries with *methods for loading or storing data* (for every
supported file extensions there may be registered a load/store method).

For add a new load/store method there are functions
*register_(load/store)_function*. The functions takes a name of the file
extension (it must be in a supported file types list) and a load/store function.

There is also method for getting visual representation of a data; the method
+get_view+ that returns a gtk component or +None+ (default).

Methods for load, store, and visualization data contains a reference
to the application instance, where is a lot of useful methods, for dialogs,
catching exceptions, etc.

There is an example of an easy data type for working with 'csv' files. The
example shows how to add a new data type. Every (new) data type is a part of
the module +datatypes+.

.Example of add a new data type
[source,python]
-------------------------------------------------------------------------------
t_table = Type("Table", "Table", ["csv"]) # <1>

def load_csv(filename, app, setting): # <2>
    if setting is None:
        setting = show_csv_setting_dialog(app.window)
        t_table.setting = setting
    if setting is None:
        return # setting was canceled

    delimiter, quotechar, has_header = setting
    with open(filename, "rb") as csvfile:
        csvreader = csv.reader(
            csvfile, delimiter=delimiter, quotechar=quotechar)

        data = []
        try:
            if has_header:
                header = csvreader.next()
            else:
                row = csvreader.next()
                data.append(row)
                count = len(row)
                header = ["V{0}".format(i) for i in xrange(count)]
        except StopIteration:
            return (["V0"], [])

        for row in csvreader:
            data.append(row)
        return (header, data)
t_table.register_load_function("csv", load_csv) # <3>

...
-------------------------------------------------------------------------------

<1> Create a new data type.
<2> Define a method for loading data. It takes a name of a file, a reference to
the application, and a <<inner-setting, setting>>.
<3> Register the load function to the data type; bind this to 'csv' format.

[[inner-setting]]
.Setting
The functions for load and store data may require some setting from a user.
E.g. the function +load_csv+ requires information about type of separator or
items delimiter. In this case; if the setting is once given then
the same one is used by the next calling on the same file. If the setting
is empty then is show a dialog (method: +show_csv_setting_dialog+). The easy
way how to create that dialog will be shown in the <<setting-widget-category,
setting widget>> category.

.Finalize the example of adding new data type
[source,python]
-------------------------------------------------------------------------------
...

def store_csv(data, filename, file_extension, app, setting): # <1>
    header, rows = data
    if setting is None:
        setting = show_csv_setting_dialog(app.window)
    delimiter, quotechar, has_header = setting
    with open("{0}.{1}".format(filename, file_extension), "wb") as csvfile:
        csvwriter = csv.writer(
            csvfile, delimiter=delimiter, quotechar=quotechar)
        if has_header:
            csvwriter.writerow(header)
        for row in rows:
            csvwriter.writerow(row)
t_table.register_save_function("csv", store_csv) # <2>

def csv_view(data, app): # <3>
    header, rows = data
    colnames = [(title, str) for title in header]

    view = gtkutils.SimpleList(colnames)
    idx = 1
    for row in rows:
        try:
            view.append(row)
            idx += 1
        except ValueError:
            required_len = len(header) if header is not None else len(rows[0])
            msg = ("Row sequence has wrong length. It must have {0} items"
                    " instead of {1}.\nThe problem row is index is {2}.".
                        format(required_len, len(row), idx))
            app.show_message_dialog(msg, gtk.MESSAGE_WARNING)
    return view
t_table.get_view = csv_view # <4>

types_repository.append(t_table) # <5>
-------------------------------------------------------------------------------

<1> Define a method for storing data. It takes a data, a name of a file,
file extensions, a reference to the application, and <<inner-setting, setting>>.
<2> Register the save function to the 'csv' files types.
<3> Define method for visualize data. It creates a list of rows of a table.
<4> Assign the visualization method.
<5> Append the new data type to the types repository which is part of the
+datatypes+ module.

Operation
~~~~~~~~~

The extensions are provided in form of operations. It is similar to
mathematical conception of operations. An operation has some inputs parameters
and produce some outputs (from 'zero' to 'N' outputs are allowed).
The operation as such does not have any side effect, only it takes inputs and
produce outputs.

All of the operations (extensions) are stored in the directory:
+$KAIRA_DIR/gui/extensions/+. Operations in modules there are automatically
loaded after start application. One module can get together more operations.

All the supportive class for creating a new operation are in
+gui/extensions.py+ module. For creating a new operation is necessary to make
a new module in +gui/extensions/+ or use one of existing. Every operation
extends the +extensions.Operation+ class.

.Create an operation for filtering table data
[source,python]
-------------------------------------------------------------------------------
import gtk
import settingswindow
from extensions import Argument, Source, Operation, add_operation # <1>
from datatypes import t_table # <2>

class Filter(Operation): # <3>

    # <4>
    name = "Table filter"
    description = "Data are filtered by a value(s) in specific column(s)"
    arguments = [Argument("Data", t_table)]

    def run(self, app, data):
        header, rows = data

        # <5>
        assistant = settingswindow.BasicSettingAssistant(2,
                                                         "Filter setting",
                                                         app.window)
        # ... define a content of the assistant ...

        response = assistant.run()
        if response != gtk.RESPONSE_OK:
            return None

        selected_columns = assistant.collected_setting[0]["selected_cols"]
        filter_by = assistant.collected_setting[1]

        cmp_fns = {} # compare functions
        for col_idx in selected_columns:
            cmp_fns[col_idx] = filter_by.get("cmp_fn{0}".format(col_idx))

        # <6>
        # filter data
        def f(row):
            return all(cmp_fns[idx](filter_by[idx], row[idx])
                       for idx in selected_columns)

        filtered_data = (header, filter(f, rows))
        return Source("Filtered table", t_table, filtered_data) # <7>

add_operation(Filter) # <8>

-------------------------------------------------------------------------------

<1> Import important class and a function from +extensions+ module.
<2> Import required data type from +datatypes+ module.
<3> Define a new operation. 'It must extends extensions.Operation'.
<4> Define the standard parameters of an operation. These must be a class
arguments, they are constants that cannot be changed; read-only arguments.
* *name*, a name of the operation,
* *description*, a short description about what an operation does,
* *arguments*, a list of argument instances (+extensions.Argument+), from them
are generated functions parameters.

<5> Between '5' and '6' is defined an assistant widget for getting some
setting information from a user. This will be described more detailed in
a section <<setting-widget-category, setting widget>> category.
<6> There is the proper body of the operation, there is a code for filtering
data.
<7> The resulting data are packed to a Source and it is returned as result of
the function. *The all of the functions must return a +extension.Source+ type
or a list of sources.
<8> The last and the most important think is that *every operation* which should
be visible in the extension manager *must be registered*. For this there is
the method +extensions.add_operation+. It takes a reference to a class of
an operation.

Visualization of operations
^^^^^^^^^^^^^^^^^^^^^^^^^^^
When you are finished your operation and it is successfully loaded than you
will see it in the tool window. It is look like at the following picture:
image:img/tool-window.png[alt="Tools window visualization", width=800]

If a user create his/her operation in the same way as it was described above
than the visualization of an operation and its integration to the extension
manager is done automatically.


[[setting-widget-category]]
Setting widget
--------------
 ...
