
Kaira Developer's Guide
=======================

This guide serves as a manual for developers. There are described the basic
components of tool Kaira (http://verif.cs.vsb.cz/kaira).

User's extensions
-----------------
Kaira can be extended by user's extensions. They serve primary for data
processing. Under the term of 'extension' is considered to be one or more
<<sec-operation, operations>>.

Every <<sec-operation, operation>> represents a function that takes some inputs
data and produces some outputs data. Both of these types of data are not
usually build-in types. By types in this context we mean objects like
tracelogs, control sequences, or tables.

At the first part there will be a short tutorial to those data types. There
will be described how to work with existing data types or how to create new
ones. In the next part follows a description of work with operations and
there is also a short tutorial how to create a new operation. At the end of
both part is subsection '``Inside the module''' where is the reference
manual for all classes of appropriate module.

[[sec-datatypes]]
Data types
~~~~~~~~~~

This section describes 'data types' used in <<sec-operation, operations>>.
Every data types are represented by instances of class <<cls-type, Type>>.
They serve as a description of basic objects with which a user can manipulate
like tracelog, tables, etc. They contain also three basic functions for:
*load*, *store*, and *visualization* of data.

The following example shows how to simply add a new data type. Every data type
consists:

- 'name',
- 'short name', and
- 'list of supported file types' (files extensions).

A 'name' is full name of the data type which is used for example in
<<cls-sourceview, SourceView>>. In contrast, a 'short name' is used on places
where is not a lot of space for full name, like in the filters of files. If the
full name is short enough, it may be the same as the short name.

.Add a new data type
[source,python]
-------------------------------------------------------------------------------
t_table = Type("Table", "Table", ["csv", "xls"]) # <1>
types_repository.append(t_table) # <2>
-------------------------------------------------------------------------------

<1> Create new 'table' data type.
<2> Register the data type to a types repository.

That is all, it is enough for create and register new data type. But a data
type without supportive functions has quite limited use. Because data cannot
be loaded/stored from/to a file (they can be produced only by other
operations), etc.

The following example shows how to add supportive functions to a data type.
For this we will use already defined data type +t_table+.

.Add basic functions to a data type
[source, python]
-------------------------------------------------------------------------------
def load_csv(filename, app, setting): # <1>
    # code of the function
t_table.register_load_function("csv", load_csv) # <2>

def load_xls(filename, app, setting): # <3>
    # code of the function
t_table.register_load_function("xls", load_xls) # <4>

def store_csv(data, filename, file_extension, app, setting) # <5>
    # code of the function
t_table.register_store_function("csv", store_csv) # <6>

def table_view(data, app): # <7>
    # code of the function
t_table.get_view = table_view # <8>
-------------------------------------------------------------------------------

<1> Create a function for loading data from 'csv' files.
<2> Register the loading function to +t_table+ data type.
<3> Create a function for loading data from 'xls' files.
<4> Register the loading function to +t_table+ data type.
<5> Create a function for storing data in 'csv' format to a file.
<6> Register the storing function to +t_table+ data type.
<7> Create a function for visualization table data.
<8> Assign the visualization function to +t_table.get_view+ function.

As you can see there is missing a function for store data in 'xls' format.
That means the data will not be able save in this format on so defined data
type. But still it will be able to store them in 'csv' format. It is
-- and must be -- possible to load data from one format and store them into
other. Because a data type brings together one type of data with many formats
of representation.

In the following subsection you will find the referece manual for +datatypes+
module. There is also a detailed description of arguments of functions for
<<fn-load,loading>>, <<fn-store, storing>>, and <<fn-visualize, visualization>>
data.

Inside of datatypes module
^^^^^^^^^^^^^^^^^^^^^^^^^^

.List of classes
- <<cls-datatypeexception, DataTypeException>>
- <<cls-noloaderexists, NoLoaderExists>>
- <<cls-nosaverexists, NoSaverExists>>
- <<cls-type, Type>>
- <<impl-types, implemented data types>>

[[cls-datatypeexception]]
`DataTypeException` class
++++++++++++++++++++++++

This exception servers as super class for all the others exceptions from
this module.

.Extends
- Exception

[[cls-noloadeexists]]
`NoLoaderExists` class
++++++++++++++++++++

Exception for situations when is not defined a loader for a specific file type
(for a specific file extension).

.Extends
- DataTypeException

[[cls-nosaverexists]]
`NoSaverExists` class
+++++++++++++++++++
Exception for situations when is not defined a saver for a specific file type
(for a specific file extension).

.Extends
- DataTypeException

[[cls-type]]
`Type` class
++++++++++

From this class are derived all of data types.

.Extends
- object

.Constructor
- Type(name, short_name, files_extensions)

.Properties
- 'name' -- a full name of a data type
- 'short_name' -- shorter version of a name
- 'files_extensions' -- a list of files extensions that are supported by the
type
- 'setting' -- an optional variable which can carry a setting from a user
- 'loaders' -- a dictionary with registered loaders for a specific file
extension (file extension: load function)
- 'savers' -- a dictionary with registered savers for a specific file
extension (file extension: save function)

.Methods
- [[fn-load]]'load_source(filename, app, setting=None)' -- call functions
stored in the 'loaders' dictionary by the extension of filename
* 'filename' -- a name of file (include a path where the data will be stored)
* 'app' -- a reference to the main application; there is a lot of useful
functions
* 'setting' -- an optional argument (default: +None+) where may be stored some
user's setting informations
- [[fn-store]]'store_source(data, filename, file_extension, app, setting=None)'
-- call functions stored in the 'savers' dictionary by a file_extension
* 'data' -- a reference to data in memory
* 'filename' -- a name of file (include a path) but without extension
* 'file_extension' -- an extension of file which determines data format
* 'app' -- a reference to the main application
* 'setting' -- an optional argument (default +None+) where may be stored some
user's setting information
- [[fn-visualize]]'get_view(data, app)' -- return a widget with visualized data
- 'register_load_function(extension, function)' -- register a loading
function to a file extension
- 'register_store_function(extension, function)' -- register a saving function
to a file extension

Implemented data types
++++++++++++++++++++++

.Tracelog (+t_tracelog+)
This data type represents data produced by applications made by Kaira, if they
are run in tracing mode.

- 'supported file types'
* *kth* (kaira tracelog header)
** 'loader' -- yes
** 'saver' -- no
- 'visualization widget' - yes (replay)

.Table (+t_table+)
This data type represents data which they are stored in form of table.

- 'supported file types'
* *csv* (comma separated values)
** 'loader' -- yes
** 'saver' -- yes
- 'visualization widget' - yes


Operations
~~~~~~~~~~
As it was said, operations represent function which takes some inputs data and
produce some outputs data. It is similar to the mathematical concept of a
function. Operations as such do not have any side effects; but they only take
inputs and produce outputs.

All of the modules with operations are stored in the directory
+$KAIRA_DIR/gui/extensions/+. One module can bring together more operations.
Every of registered operations is automatically loaded after start of the
application.Operations that are contained in some module, but they are not
registered then they are invisible for the application. How to create and
register an operation will be shown in following examples.

All the supportive classes for creating a new operation are in
+gui/extensions.py+ module. For creating a new operation is necessary to make
a new module in +gui/extensions/+ or use one of the existing. Every operation
extends the +extensions.Operation+ class.

.Create an operation for filtering table's data
[[src-operation-example]]
[source,python]
-------------------------------------------------------------------------------
import gtk
from extensions import Argument, Source, Operation, add_operation # <1>
from datatypes import t_table # <2>

class Filter(Operation): # <3>

    # <4>
    name = "Table filter"
    description = "Data are filtered by a value(s) in specific column(s)"
    arguments = [Argument("Data", t_table)]

    def run(self, app, data):
        header, rows = data

        def f(row):
            # code of filtering function

        filtered_data = (header, filter(f, rows)) # <5>
        return Source("Filtered table", t_table, filtered_data) # <6>

add_operation(Filter) # <7>

-------------------------------------------------------------------------------

<1> Import the important classes and functions from +extensions+ module.
<2> Import required data type from +datatypes+ module.
<3> Define a new operation. 'It must extends <<cls-operation, Operation>>
class'.
<4> Defining of the standard parameters of an operation. These must be
arguments of a class. They represent constants that cannot be changed.
* 'name' -- a name of an operation,
* 'description' -- a short description about what an operation does,
* 'arguments' -- a list of <<cls-argument, arguments>> instances, from
them are generated functions parameters. The difference between
<<cls-argument,arguments>> and <<cls-parameter, parameters>> is that parameters
are carrier of data.
<5> filter data and prepare a result for creating output <<cls-source,source>>.
<6> Resulting data is packed to a <<cls-source,Source>> and it is returned
as the result of the function. The all of functions must return a
<<cls-source, Source>> type or a list of sources.
<7> The last and the most important thing is: *every operations* which should
be visible in the extension manager *must be registered*. For this, there is
method +extensions.add_operation+. It takes a reference to a class of
an operation.

Visualization of operations
^^^^^^^^^^^^^^^^^^^^^^^^^^^
When a developer finishes his/her operation and it is successfully loaded into
the application then it can be seen in tools window. It looks like on the
following picture:

[[img-tool-window]]
image:img/tool-window.png[alt="Tools window visualization", width=800]

If a user create his/her operation in the same way as it was described above
than the visualization of an operation and its integration to the extension
manager is done automatically.

Inside of extensions module
^^^^^^^^^^^^^^^^^^^^^^^^^^^

This subsection detailing describes all parts of extensions' module. At the
beginning there is a picture showing a class digram of all classes in module
+extensions+ and their relations.

[[img-extensions-cls-diag]]
image:img/extensions-class-diagram.png[alt="Class diagram of module's classes",
                                       width=600]

<<module-extensions, extensions module>>

.List of classes
- <<cls-source, Source>>
- <<cls-sourceview, SourceView>>
- <<cls-sourcerepository, SourceRepository>>
- <<cls-sourcerepositoryview, SourceRepositoryView>>
- <<cls-argument, Argument>>
- <<cls-parameter, Parameter>>
- <<cls-parameterview, ParameterView>>
- <<cls-operation, Operation>>
- <<cls-operationshortview, OperationShortView>>
- <<cls-operationfullview, OperationFullView>>
- <<cls-extensionmanager, ExtensionManager>>


[[cls-source]]
Source class
++++++++++++

.Extends
- object
- events.EventSource

.Constructor
- Source(name, type, data, stored=False)

.Properties
- 'name' -- a name of a source, typically it is a name of file where are data
stored. The *name must be unique* in the frame of <<cls-sourcesrepository,
sources repository>>. If the name is changed than it is emit
'source-name-changed' event.
- 'type' -- a type of a source, it is a reference to a specific data type from
module +datatypes+, e.g. +t_table+ in <<src-operation-example,
operation example>>
- 'data' -- a reference to data that is kept there
- 'stored' -- a flag, that is true, if data is stored somewhere
on a disc, otherwise false.

[[cls-sourceview]]
SourceView class
++++++++++++++++

.Extends
- gtk.Alignment
- events.EventSource

.Constructor
- SourceView(source, app)

.Properties
- 'source' -- a reference to a <<cls-source, source>> object
- 'app' -- a reference main application (+app.App+)
- 'tabview' -- a reference to a tab with a visualization of data
(default: +None+)
- 'data_free' -- a flag, that is true, if data is free from the memory
(it means stored somewhere on a disc), otherwise they are kept in a memory
(default: +False+)

[[cls-sourcerepository]]
SourcesRepository class
+++++++++++++++++++++++

.Extends
- object
- events.EventSource

.Constructor
- SourceRepository()

.Methods
- 'add(source)' -- adds a given <<cls-source, source>>; returns true if
it is successful, otherwise false. It emits 'source-added' event
- 'remove(source)' -- remove a given <<cls-source, source>> if it is in
repository; returns true if it is successful, otherwise false
It emits 'source-removed' event
- 'get_sources(filter=None)' -- returns a list of stored <<cls-source,
sources>>. If it is a filter given then are sources filtered by data types
A [[sources-filter]]filter is a list of <<cls-type, types>> which
should be returned

[[cls-sourcerepositoryview]]
SourcesRepositoryView class
+++++++++++++++++++++++++++

.Extends
- gtk.VBox
- events.EventSource

.Constructor
- SourceRepositoryView(repository, app)

.Properties
- 'repository' -- a reference to a <<cls-sourcerepository, source repository>>
object
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'app' -- a reference main application (+app.App+)
- 'sources_views' -- a dictionary of a <<cls-source, source>> object
and his <<cls-sourceview, source view>> object

.Methods
- 'set_filter(filter)' -- show/hide sources by a given <<sources-filter,
filter>>
- 'deregister_callbacks()' -- deregister all of registered callbacks

[[cls-argument]]
Argument class
+++++++++++++++

The parameters of an argument object are not changed in the application, they
are fixed.

.Extends
- object

.Constructor
- Argument(name, type, list=False, minimum=1)

.Properties
- 'name' -- displayed name
- 'type' -- a type of argument (reference to some of specific instance of data
<<cls-type, types>>)
- 'list' -- a flag, if it is true then an argument represents a list of
values. If it is represents only one value then the 'list' is set up to false
- 'minimum' -- it has sense for arguments representing a list of values and
indicates a minimum count of values

[[cls-parameter]]
Parameter class
+++++++++++++++

.Extends
- object
- events.EventSource

.Constructor
- Parameter(argument)

.Properties
- 'name' -- a name from an argument (read-only)
- 'type' -- a type from an argument (read-only)
- 'minimum' -- a minimum value from an argument (read-only)
- 'real_attached' -- indicate how many <<cls-source, sources>> are attached to
a parameter
- 'sources' -- a list of attached sources

.Methods
- 'is_list()' -- return true if the parameter represents a list of values,
otherwise false
- 'is_empty()' -- return true if the 'real_attached' parameter is equal to zero,
otherwise
- 'sources_count()' -- return a value stored in the 'real_attached' parameter
- 'get_source(index=-1)' -- return a attached source. If the parameter
represents a list of values then is returned the last attached source
('index=-1'). If the index is given then is returned a source attached on
a specific position
- 'attach_source(source, index=None)' -- attach a given <<cls-source, source>>
to the <<cls-parameter, parameter>>. There are three possibilities of the index
value, the given index is:
1. equal to +None+ then a <<cls-source,source>> is attached at the end of
'sources'' list,
2. from range (from zero to 'real_attached') then a <<cls-source,source>> is
attached to the given position (index),
3. out of range then it is a wrong input.
- 'detach-source(index)' -- remove a <<cls-source, source>> from the 'sources''
list on the given position. It emits a 'parameter-changed' event
- 'get_data()' -- return data from attached sources. If the <<cls-parameter,
parameter>> represents a list then it is returned a list of attached sources'
data. If it is not then it is returned a reference to a source data

[[cls-parameterview]]
ParameterView class
+++++++++++++++++++

.Extends
- gtk.Table
- events.EventSource

.Constructor
- ParameterView(parameter)

.Properties
- 'parameter' -- a reference to a <<cls-parameter, parameter>> object
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'entries' -- a list of +gtk.Entry+ objects

.Methods
- 'deregister_callbacks()' -- deregister all of registered callbacks

[[cls-operation]]
Operation class
+++++++++++++++

One of the most important classes, because from this are derived all of
user's operations.

.Extends
- object
- events.EventSource

.Constructor
- Operation()

.Properties
- 'name' -- a name of an operation ('class property', 'read-only')
- 'description' -- a short description about what an operation does
('class property', 'read-only')
- 'arguments' -- a list of <<cls-argument, arguments>> objects
('class-property', 'read-only'); it serves as a description of inputs of an
operation
- 'parameters' -- a list of <<cls-parameter, parameter>> objects which are
initialized based of 'arguments'; they are used for a manipulating with inputs
of an operation, they are carrier of data
- 'selected_parameter' -- store an information about <<cls-parameter,
parameter>>> and their index; it is a couple of <<cls-parameter,parameter>> and
index
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'state' -- a state of an operation, possible values are in the following
list. When the state is changed than it is emitted a 'state-changed' event
* *ready* -- when an operation has all of required sources; it can be run
* *incomplete* -- when some of required sources are missing
* *incorrect* -- reserved value, it is not used yet

.Methods
- 'select_parameter(parameter, index)' -- set a <<cls-parameter, parameter>>
as a selected
- 'run(app, \*args)' -- the method which a developer of some his/her operation
must implement. It takes the same arguments which are specified in a list
'arguments'. It *is not* references to items in that list, but a names of
``real parameters'' which represent some of real data
- 'execute(app)' -- take data stored in all of <<cls-parameter, parameters>>,
collect them and call the 'run' method
[source, python]
-------------------------------------------------------------------------------
def execute(self, app):
    args = [parameter.get_data() for parameter in self.parameters]
    return self.run(app, *args)
-------------------------------------------------------------------------------
- 'attach-source(source)' -- attach source to a first free slot; if there is
no one then it is emitted a 'no-free-slot' event
- 'all_sources_filled()' -- check whether all parameter has attached a source
or not
- 'deregister_callbacks()' -- deregister all of registered callbacks

[[cls-operationshortview]]
OperationShortView class
++++++++++++++++++++++++

This component is used for showing all of loaded operations.

.Extends
- gtk.Alignment
- events.EventSource

.Constructor
- OperationShortView(operation)

.Properties
- 'operation' -- a reference to an <<cls-operation, operation>> object

.Methods
- 'deregister_callbacks()' -- deregister all of registered callbacks


[[cls-operationfullview]]
OperationFullView class
+++++++++++++++++++++++

A full view widget is used for selected operation, there can be sources
attached or operation can be fired

.Extends
- gtk.VBox
- events.EventSource

.Constructor
- OperationFullView(app)

.Properties
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'app' -- a reference main application (+app.App+)
- 'operation' -- a reference to an <<cls-operation, operation>> object
(default: None)

.Methods
- 'set_operation(operation)' -- destroy widget and make them again based on
the given <<cls-operation, operation>>
- 'deregister_callbacks()' -- deregister all of registered callbacks

[[cls-extensionmanager]]
ExtensionManager class
+++++++++++++++++++++++

Extension manager is a top-level widget that cares about all of operations and
their usage. It is responsible for communication between other components.

.Extends
- gtk.VBox

.Constructor
- ExtensionManager(sources_repository, app)

.Properties
- 'app' -- a reference main application (+app.App+)
- 'loaded_operations' -- a list of all loaded operations from a +gui/extensions+
directory
- 'full_view' -- reference to an <<cls-operationfullview, operation full view>>
widget. It is known as visualization of a selected operation
- 'sources_repository' -- reference to a <<cls-sourcesrepository,
repository with all sources>>
- 'sources_tile' -- a reference to a title above  <<cls-sourcesrepositoryview,
view of sources repository>>; when the filter is activated then in a label is
showed how many items is visible from all of them
- 'sources_view' -- a reference to a <<cls-sourcesrepositoryview, view of
sources repository>>
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)

[[module-extensions]]
Extensions module
+++++++++++++++++

A module contains two functions:

- 'add_operation(operation)' every user's operation must call this function
for register his/her operation. It takes a reference to an operation's class,
*not an instance*
- 'load_extensions()' it is responsible for loading all user's operations. It
is called always after import this module

[[setting-widget-category]]
Setting widget
--------------
 ...
