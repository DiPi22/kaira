
Kaira Developer's Guide
=======================

This guide serves as a manual for developers. There are described the basic
components of tool Kaira (http://verif.cs.vsb.cz/kaira).

User's extensions
-----------------
Kaira can be extended by user's extensions. They serve primary for data
processing. Under the term of 'extension' is considered to be one or more
<<sec-operation, operations>>.

Every <<sec-operation, operation>> represents a function that takes some inputs
data and produces some outputs data. Both of these types of data are not
usually build-in types. By types in this context we mean objects like
tracelogs, control sequences, or tables.

At the first part there will be a short tutorial to those data types. There
will be described how to work with existing data types or how to create new
ones. In the next part follows a description of work with operations and
there is also a short tutorial how to create a new operation. At the end of
both part is subsection '``Inside the module''' where is the reference
manual for all classes of appropriate module.

[[sec-datatypes]]
Data types
~~~~~~~~~~

This section describes 'data types' used in <<sec-operation, operations>>.
Every data types are represented by instances of class <<cls-type, Type>>.
They serve as a description of basic objects with which a user can manipulate
like tracelog, tables, etc. They contain also three basic functions for:
*load*, *store*, and *visualization* of data.

All of data types whether the existing ones or those are not implemented yet
are located in module +datatypes+. It means that, if a user wants to add a new
data type it will be added to +$KAIRA/gui/datatypes.py+ source file.
// TODO: konvece je protoze, nekteri dalsi mohou chtit pouzivat tvuj typ,
// a zda se mi lepsi to mit na jednom miste nez to lovit vsude mozne.

The following example shows how to simply add a new data type. Every data type
consists:

- 'name',
- 'short name', and
- 'list of supported file types' (files extensions).

A 'name' is full name of the type which is used for example in
<<cls-sourceview, SourceView>>. In contrast, a 'short name' is used on places
where is not a lot of space for full name, like in the filters of files. If the
full name is short enough, it may be the same as the short name.

.Add a new data type
[source,python]
-------------------------------------------------------------------------------
t_table = Type("Table", "Table", ["csv", "xls"]) # <1>
types_repository.append(t_table) # <2>
-------------------------------------------------------------------------------

<1> Create new 'table' data type.
<2> Register the data type to a types repository.

That is all, it is enough for create and register new data type. But a data
type without supportive functions has quite limited use. Because data cannot
be loaded/stored from/to a file (they can be produced only by other
operations), etc.

The following example shows how to add supportive functions to a data type.
For this we will use already defined type +t_table+.

.Add basic functions to a data type
[source, python]
-------------------------------------------------------------------------------
def load_csv(filename, app, setting): # <1>
    # code of the function
t_table.register_load_function("csv", load_csv) # <2>

def load_xls(filename, app, setting): # <3>
    # code of the function
t_table.register_load_function("xls", load_xls) # <4>

def store_csv(data, filename, file_extension, app, setting) # <5>
    # code of the function
t_table.register_store_function("csv", store_csv) # <6>

def table_view(data, app): # <7>
    # code of the function
t_table.get_view = table_view # <8>
-------------------------------------------------------------------------------

<1> Create a function for loading data from 'csv' files.
<2> Register the loading function to +t_table+ type.
<3> Create a function for loading data from 'xls' files.
<4> Register the loading function to +t_table+ type.
<5> Create a function for storing data in 'csv' format to a file.
<6> Register the storing function to +t_table+ type.
<7> Create a function for visualization table data.
<8> Assign the visualization function to +t_table.get_view+ function.

As you can see there is missing a function for store data in 'xls' format.
That means the data will not be able save in this format on so defined data
type. But still it will be able to store them in 'csv' format. It is
-- and must be -- possible to load data from one format and store them into
other. Because a data type brings together one type of data with many formats
of representation.

In the following subsection you will find the referece manual for +datatypes+
module. There is also a detailed description of arguments of functions for
<<fn-load,loading>>, <<fn-store, storing>>, and <<fn-visualize, visualization>>
data.

Inside of datatypes module
^^^^^^^^^^^^^^^^^^^^^^^^^^

.List of classes
- <<cls-datatypeexception, DataTypeException>>
- <<cls-noloaderexists, NoLoaderExists>>
- <<cls-nosaverexists, NoSaverExists>>
- <<cls-type, Type>>
- <<impl-types, implemented data types>>

[[cls-datatypeexception]]
`DataTypeException` class
++++++++++++++++++++++++

This exception servers as super class for all the others exceptions from
this module.

.Extends
- Exception

[[cls-noloadeexists]]
`NoLoaderExists` class
++++++++++++++++++++

Exception for situations when is not defined a loader for a specific file type
(for a specific file extension).

.Extends
- DataTypeException

[[cls-nosaverexists]]
`NoSaverExists` class
+++++++++++++++++++
Exception for situations when is not defined a saver for a specific file type
(for a specific file extension).

.Extends
- DataTypeException

[[cls-type]]
`Type` class
++++++++++

From this class are derived all of data types.

.Extends
- object

.Constructor
- Type(name, short_name, files_extensions)

.Properties
- 'name' -- a full name of a data type
- 'short_name' -- shorter version of a name
- 'files_extensions' -- a list of files extensions that are supported by the
type
- 'setting' -- an optional variable which can carry a setting from a user
- 'loaders' -- a dictionary with registered loaders for a specific file
extension (file extension: load function)
- 'savers' -- a dictionary with registered savers for a specific file
extension (file extension: save function)

.Methods
- [[fn-load]]'load_source(filename, app, setting=None)' -- call functions
stored in the 'loaders' dictionary by the extension of filename.
* 'filename' -- a name of file (include a path where the data will be stored)
* 'app' -- a reference to the main application; there is a lot of useful functions
* 'setting' -- an optional argument (default: +None+) where may be stored some
user's setting informations.
- [[fn-store]]'store_source(data, filename, file_extension, app, setting=None)'
-- call functions stored in the 'savers' dictionary by a file_extension
* 'data' -- a reference to data in memory
* 'filename' -- a name of file (include a path) but without extension
* 'file_extension' -- an extension of file which determines data format
* 'app' -- a reference to the main application
* 'setting' -- an optional argument (default +None+) where may be stored some
user's setting information
- [[fn-visualize]]'get_view(data, app)' -- return a widget with visualized data
- 'register_load_function(extension, function)' -- register a loading
function to a file extension
- 'register_store_function(extension, function)' -- register a saving function
to a file extension

Implemented data types
++++++++++++++++++++++

.Tracelog (+t_tracelog+)
This type represents data produced by applications made by Kaira, if they are
run in tracing mode.

- 'supported file types'
* *kth* (kaira tracelog header)
** 'loader' -- yes
** 'saver' -- no
- 'visualization widget' - yes (replay)

.Table (+t_table+)
This type represents data which they are stored in form of table.

- 'supported file types'
* *csv* (comma separated values)
** 'loader' -- yes
** 'saver' -- yes
- 'visualization widget' - yes


Operations
~~~~~~~~~~

The extensions are provided in form of operations. It is similar to
mathematical conception of operations. An operation has some inputs parameters
and produce some outputs (from 'zero' to 'N' outputs are allowed).
The operation as such does not have any side effect, only it takes inputs and
produce outputs.

All of the operations (extensions) are stored in the directory:
+$KAIRA_DIR/gui/extensions/+. Operations in modules there are automatically
loaded after start application. One module can get together more operations.

All the supportive class for creating a new operation are in
+gui/extensions.py+ module. For creating a new operation is necessary to make
a new module in +gui/extensions/+ or use one of existing. Every operation
extends the +extensions.Operation+ class.

.Create an operation for filtering table data
[[src-operation-example]]
[source,python]
-------------------------------------------------------------------------------
import gtk
import settingswindow
from extensions import Argument, Source, Operation, add_operation # <1>
from datatypes import t_table # <2>

class Filter(Operation): # <3>

    # <4>
    name = "Table filter"
    description = "Data are filtered by a value(s) in specific column(s)"
    arguments = [Argument("Data", t_table)]

    def run(self, app, data):
        header, rows = data

        # <5>
        assistant = settingswindow.BasicSettingAssistant(2,
                                                         "Filter setting",
                                                         app.window)
        # ... define a content of the assistant ...

        response = assistant.run()
        if response != gtk.RESPONSE_OK:
            return None

        selected_columns = assistant.collected_setting[0]["selected_cols"]
        filter_by = assistant.collected_setting[1]

        cmp_fns = {} # compare functions
        for col_idx in selected_columns:
            cmp_fns[col_idx] = filter_by.get("cmp_fn{0}".format(col_idx))

        # <6>
        # filter data
        def f(row):
            return all(cmp_fns[idx](filter_by[idx], row[idx])
                       for idx in selected_columns)

        filtered_data = (header, filter(f, rows))
        return Source("Filtered table", t_table, filtered_data) # <7>

add_operation(Filter) # <8>

-------------------------------------------------------------------------------

<1> Import important class and a function from +extensions+ module.
<2> Import required data type from +datatypes+ module.
<3> Define a new operation. 'It must extends extensions.Operation'.
<4> Define the standard parameters of an operation. These must be a class
arguments, they are constants that cannot be changed; read-only arguments.
* 'name' -- a name of the operation,
* 'description' -- a short description about what an operation does,
* 'arguments' -- a list of argument instances (+extensions.Argument+), from them
are generated functions parameters.

<5> Between '5' and '6' is defined an assistant widget for getting some
setting information from a user. This will be described more detailed in
a section <<setting-widget-category, setting widget>> category.
<6> There is the proper body of the operation, there is a code for filtering
data.
<7> The resulting data is packed to a Source and it is returned as result of
the function. *The all of the functions must return a +extension.Source+ type
or a list of sources.
<8> The last and the most important think is that *every operation* which should
be visible in the extension manager *must be registered*. For this there is
the method +extensions.add_operation+. It takes a reference to a class of
an operation.

Visualization of operations
^^^^^^^^^^^^^^^^^^^^^^^^^^^
When you are finished your operation and it is successfully loaded than you
will see it in the tool window. It is look like at the following picture:

[[img-tool-window]]
image:img/tool-window.png[alt="Tools window visualization", width=800]

If a user create his/her operation in the same way as it was described above
than the visualization of an operation and its integration to the extension
manager is done automatically.

Inside of extensions module
^^^^^^^^^^^^^^^^^^^^^^^^^^^

This part detailing describe all parts of extensions' module. At the beginning
there is a picture showing a class digram of all classes in the module and
their relations.

[[img-extensions-cls-diag]]
image:img/extensions-class-diagram.png[alt="Class diagram of module's classes",
                                       width=600]

<<module-extensions, extensions module>>

.List of classes
- <<cls-source, Source>>
- <<cls-sourceview, SourceView>>
- <<cls-sourcerepository, SourceRepository>>
- <<cls-sourcerepositoryview, SourceRepositoryView>>
- <<cls-argument, Argument>>
- <<cls-parameter, Parameter>>
- <<cls-parameterview, ParameterView>>
- <<cls-operation, Operation>>
- <<cls-operationshortview, OperationShortView>>
- <<cls-operationfullview, OperationFullView>>
- <<cls-extensionmanager, ExtensionManager>>


[[cls-source]]
Source class
++++++++++++

.Extends
- object
- events.EventSource

.Constructor
- Source(name, type, data, stored=False)

.Properties
- 'name' -- a name of a source, typically it is a name of file where are data,
stored. A *name must be unique* in the frame of <<cls-sourcesrepository,
sources repository>>. If the name is changed than it is emit
'source-name-changed' event.
- 'type' -- a type of a source, it is a reference to a specific data type from
module +datatypes+, e.g. +t_table+ in <<src-operation-example,
operation example>>
- 'data' -- a reference to data that is kept there
- 'stored' -- a flag, that is true, if data is stored somewhere
on a disc, otherwise false.

[[cls-sourceview]]
SourceView class
++++++++++++++++

.Extends
- gtk.Alignment
- events.EventSource

.Constructor
- SourceView(source, app)

.Properties
- 'source' -- a reference to a <<cls-source, source>> object
- 'app' -- a reference main application (+app.App+)
- 'tabview' -- a reference to a tab with a visualization of data
(default: +None+)
- 'data_free' -- a flag, that is true, if data is free from the memory
(it means stored somewhere on a disc), otherwise they are kept in a memory
(default: +False+).

[[cls-sourcerepository]]
SourcesRepository class
+++++++++++++++++++++++

.Extends
- object
- events.EventSource

.Constructor
- SourceRepository()

.Methods
- 'add(source)' -- adds a given <<cls-source, source>>; returns true if
it is successful, otherwise false. It emits 'source-added' event.
- 'remove(source)' -- remove a given <<cls-source, source>> if it is in
repository; returns true if it is successful, otherwise false.
It emits 'source-removed' event.
- 'get_sources(filter=None)' -- returns a list of stored <<cls-source,
sources>>. If it is a filter given then are sources filtered by types.
A [[sources-filter]]filter is a list of types (+datatypes.Type+) which
should be returned.

[[cls-sourcerepositoryview]]
SourcesRepositoryView class
+++++++++++++++++++++++++++

.Extends
- gtk.VBox
- events.EventSource

.Constructor
- SourceRepositoryView(repository, app)

.Properties
- 'repository' -- a reference to a <<cls-sourcerepository, source repository>>
object
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'app' -- a reference main application (+app.App+)
- 'sources_views' -- a dictionary of a <<cls-source, source>> object
and his <<cls-sourceview, source view>> object

.Methods
- 'set_filter(filter)' -- show/hide sources by a given <<sources-filter,
filter>>.
- 'deregister_callbacks()' -- deregister all of registered callbacks.

[[cls-argument]]
Argument class
+++++++++++++++

The parameters of an argument object are not changed in the application, they
are fixed.

.Extends
- object

.Constructor
- Argument(name, type, list=False, minimum=1)

.Properties
- 'name' -- displayed name
- 'type' -- a type of argument (reference to +datatypes.Type+ object)
- 'list' -- a flag, if it is true then an argument represents a list of
values. If it is represents only one value then the 'list' is set up to false.
- 'minimum' -- it has sense for arguments representing a list of values and
indicates a minimum count of values.

[[cls-parameter]]
Parameter class
+++++++++++++++

.Extends
- object
- events.EventSource

.Constructor
- Parameter(argument)

.Properties
- 'name' -- a name from an argument (read-only)
- 'type' -- a type from an argument (read-only)
- 'minimum' -- a minimum value from an argument (read-only)
- 'real_attached' -- indicate how many <<cls-source, sources>> are attached to
a parameter.
- 'sources' -- a list of attached sources

.Methods
- 'is_list()' -- return true if the parameter represents a list of values,
otherwise false
- 'is_empty()' -- return true if the 'real_attached' parameter is equal to zero,
otherwise
- 'sources_count()' -- return a value stored in the 'real_attached' parameter
- 'get_source(index=-1)' -- return a attached source. If the parameter
represents a list of values then is returned the last attached source
('index=-1'). If the index is given then is returned a source attached on
a specific position.
- 'attach_source(source, index=None)' -- attach to a parameter given
<<cls-source, source>>. If the index is None then it is attached to the and
of 'sources' list. If it is not then the <<cls-source, source>> is attached to a
given position. It emits a 'parameter-changed' event.
- 'detach-source(index)' -- remove a <<cls-source, source>> from the 'sources'
list on the given position. It emits a 'parameter-changed' event.
- 'get_data()' -- return a data from attached sources. If the <<cls-parameter,
parameter>> represents a list then it is returned a list of attached sources'
data. If it is not then is returned a reference to a source data.

[[cls-parameterview]]
ParameterView class
+++++++++++++++++++

.Extends
- gtk.Table
- events.EventSource

.Constructor
- ParameterView(parameter)

.Properties
- 'parameter' -- a reference to a <<cls-parameter, parameter>> object
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'entries' -- a list of +gtk.Entry+ objects

.Methods
- 'deregister_callbacks()' -- deregister all of registered callbacks.

[[cls-operation]]
Operation class
+++++++++++++++

One of the most important classes, because from this are derived all of
user's operations.

.Extends
- object
- events.EventSource

.Constructor
- Operation()

.Properties
- 'name' -- a name of an operation ('class property', 'read-only')
- 'description' -- a short description about what an operation does
('class property', 'read-only')
- 'arguments' -- a list of <<cls-argument, arguments>> objects ('class-property',
'read-only'); it serves as description of inputs of an operation.
- 'parameters' -- a list of <<cls-parameter, parameter>> objects which are
initialized based of 'arguments'; they are used for a manipulating with inputs
of an operation
- 'selected_parameter' -- store an information about parameter and their index;
it is a couple of (parameter, index)
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'state' -- a state of an operation, possible values are in the following
list. When is state changed than it is emitted a 'state-changed' event.
* *ready* -- when an operation has all of required sources; it can be run
* *incomplete* -- when some of required sources are missing
* *incorrect* -- reserved value, it is not used yet.

.Methods
- 'select_parameter(parameter, index)' -- set a <<cls-parameter, parameter>>
as a selected.
- 'run(app, \*args)' -- the method which a developer of a his/her operation must
implement. It takes the same arguments which are specified in a list
'arguments'. It *is not* references to items in that list, but a names of
``real parameters'' which represent some real data.
- 'execute(app)' -- take a data stored in all of <<cls-parameter, parameters>>,
collect them and call the 'run' method.
[source, python]
-------------------------------------------------------------------------------
def execute(self, app):
    args = [parameter.get_data() for parameter in self.parameters]
    return self.run(app, *args)
-------------------------------------------------------------------------------
- 'attach-source(source)' -- attach source to a first free slot; if there is
no one then is emitted a 'no-free-slot' event.
- 'all_sources_filled()' -- check whether all parameter has attached a source
or not
- 'deregister_callbacks()' -- deregister all of registered callbacks.

[[cls-operationshortview]]
OperationShortView class
++++++++++++++++++++++++

This component is used for showing all of loaded operations.

.Extends
- gtk.Alignment
- events.EventSource

.Constructor
- OperationShortView(operation)

.Properties
- 'operation' -- a reference to a <<cls-operation, operation>> object

.Methods
- 'deregister_callbacks()' -- deregister all of registered callbacks.


[[cls-operationfullview]]
OperationFullView class
+++++++++++++++++++++++

A full view widget is used for selected operation, there can be sources
attached or operation fired.

.Extends
- gtk.VBox
- events.EventSource

.Constructor
- OperationFullView(app)

.Properties
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)
- 'app' -- a reference main application (+app.App+)
- 'operation' -- a reference to a <<cls-operation, operation>> object
(default: None)

.Methods
- 'set_operation(operation)' -- destroy widget and make them again based on
the given <<cls-operation, operation>>.
- 'deregister_callbacks()' -- deregister all of registered callbacks.

[[cls-extensionmanager]]
ExtensionManager class
+++++++++++++++++++++++

Extension manager is a top-level widget that cares about all of operations and
their usage. It is responsible for communication between other components.

.Extends
- gtk.VBox

.Constructor
- ExtensionManager(sources_repository, app)

.Properties
- 'app' -- a reference main application (+app.App+)
- 'loaded_operations' -- a list of all loaded operations from a +gui/extensions+
directory.
- 'full_view' -- reference to a <<cls-operationfullview, operation full view>>
widget. It is known as visualization of a selected operation.
- 'sources_repository' -- reference to a <<cls-sourcesrepository,
repository with all sources>>.
- 'sources_tile' -- a reference to a title above  <<cls-sourcesrepositoryview,
view of sources repository>>; when the filter is activated then in a label is
showed how many items is visible from all of them.
- 'sources_view' -- a reference to a <<cls-sourcesrepositoryview, view of
sources repository>>
- 'events' -- a reference to a list of callbacks (+events.EventCallbackList+)

[[module-extensions]]
Extensions module
+++++++++++++++++

A module contains two functions:

- 'add_operation(operation)' every user's operation must call this function
for register his/her operation. It takes a reference to a operation class
*not an instance*.
- 'load_extensions()' it is responsible for loading all user's operations. It
is called always after import this module.

[[setting-widget-category]]
Setting widget
--------------
 ...
