#
#    Copyright (C) 2011, 2012 Stanislav Bohm
#
#    This file is part of Kaira.
#
#    Kaira is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License, or
#    (at your option) any later version.
#
#    Kaira is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Kaira.  If not, see <http://www.gnu.org/licenses/>.
#

from builder import Builder, CppWriter, emit_declarations
from octave import OctaveBuilder
import emitter
import os
import base.utils
import paths
import shutil

class CppGenerator:

    def __init__(self, project):
        self.project = project

    def get_place_user_fn_header(self, place_id):
        place = self.project.get_place(place_id)
        t = emitter.Emitter(self.project).emit_type(place.type)
        if t[-1] == ">":
            t += " "
        return "void place_fn(CaContext &ctx, std::vector<{1}> &tokens)\n".format(place, t)

    def get_transition_user_fn_header(self, transition_id):
        transition = self.project.get_transition(transition_id)
        context = transition.get_context()
        w = CppWriter()
        em = emitter.Emitter(self.project)
        w.line("struct Vars {{")
        for key, value in context.items():
            w.line("\t{1} {0};", key, em.emit_type(value))
        w.line("}};")
        w.emptyline()
        w.line("void transition_fn(CaContext &ctx, Vars &var)")
        return w.get_string()

    def get_user_function_header(self, ufunction_name):
        ufunction = self.project.get_user_function(ufunction_name)
        em = emitter.Emitter(self.project)
        t = em.emit_type(ufunction.get_returntype())
        if ufunction.with_context:
            ctx = "CaContext &ctx, "
        else:
            ctx = ""
        decls = emit_declarations(em, ufunction.get_parameters())
        return "{0} {1}({2}{3})\n{{\n".format(t, ufunction_name, ctx, decls)

    def prepare_makefile(self, libs = [], libdir = [], include = []):

        #Add defaults
        libs.append("cailie")
        libs.append("pthread")
        libs.append("rt")
        libdir.append(paths.CAILIE_LIB_DIR)
        include.append(paths.CAILIE_DIR)

        makefile = base.utils.Makefile()
        makefile.set_top_comment("This file is autogenerated.\nDo not edit directly this file.")
        makefile.set("CC", self.project.get_build_option("CC"))
        makefile.set("CFLAGS", self.project.get_build_option("CFLAGS"))

        makefile.set("LIBDIR", " ".join(("-L" + s for s in libdir)))
        makefile.set("LIBS", " ".join(("-l" + s for s in libs)) + self.project.get_build_option("LIBS"))
        makefile.set("INCLUDE", " ".join(("-I" + s for s in include)))

        makefile.set("MPICC", "mpic++")
        makefile.set("MPILIBS", "-lcailiempi -lpthread -lrt " + self.project.get_build_option("LIBS"))
        makefile.set("MPILIBDIR", "-L" + paths.CAILIE_MPI_LIB_DIR)

        makefile.rule(".cpp.o", [], "$(CC) $(CFLAGS) $(INCLUDE) -c $< -o $@")
        makefile.rule(".cc.o", [], "$(CC) $(CFLAGS) $(INCLUDE) -c $< -o $@")
        makefile.rule(".c.o", [], "$(CC) $(CFLAGS) $(INCLUDE) -c $< -o $@")

        return makefile

    def get_other_dependancies(self):
        if self.project.get_build_option("OTHER_FILES"):
            return [ os.path.splitext(f)[0] + ".o" for f in self.project.get_build_option("OTHER_FILES").split("\n") ]
        else:
            return []

class CppProgramGenerator(CppGenerator):

    def build(self, directory):
        source_filename = os.path.join(directory, self.project.get_name() + ".cpp")

        builder = Builder(self.project, source_filename)
        builder.build()
        builder.write_to_file()

        self.write_makefile(directory)

    def write_makefile(self, directory):
        makefile = self.prepare_makefile()

        name = self.project.get_name()
        name_o = name + ".o"
        name_cpp = name + ".cpp"
        name_debug = name + "_debug"
        name_debug_o = name + "_debug.o"
        name_mpi_o = name + "_mpi.o"
        name_mpi_debug_o = name + "_mpi_debug.o"

        makefile.rule("all", [ name ], phony = True)
        makefile.rule("debug", [ name_debug ], phony = True)
        makefile.rule("mpi", [ name + "_mpi"], phony = True)
        makefile.rule("mpidebug", [name + "_mpidebug"], phony = True)

        other_deps = self.get_other_dependancies()

        deps = [ name_o ] + other_deps
        deps_debug = [ name_debug_o ] + other_deps
        deps_mpi = [ name_mpi_o ] + other_deps
        deps_mpi_debug = [ name_mpi_debug_o ] + other_deps
        makefile.rule(name, deps,
            "$(CC) " + " ".join(deps) + " -o $@ $(CFLAGS) $(INCLUDE) $(LIBDIR) $(LIBS) " )

        makefile.rule(name_debug, deps_debug,
            "$(CC) " + " ".join(deps_debug) + " -o $@ $(CFLAGS) $(INCLUDE) $(LIBDIR) $(LIBS) " )

        makefile.rule(name + "_mpi", deps_mpi, "$(MPICC) -D CA_MPI " + " ".join(deps_mpi)
            + " -o $@ $(CFLAGS) $(INCLUDE) $(MPILIBDIR) $(MPILIBS)" )
        makefile.rule(name + "_mpidebug", deps_mpi_debug, "$(MPICC) -D CA_MPI " + " ".join(deps_mpi_debug)
            + " -o $@ $(CFLAGS) $(INCLUDE) $(MPILIBDIR) $(MPILIBS)" )

        makefile.rule(name_o, [ name_cpp, "head.cpp" ], "$(CC) $(CFLAGS) $(INCLUDE) -c {0} -o {1}".format(name_cpp, name_o))

        makefile.rule(name_debug_o, [ name_cpp, "head.cpp" ],
            "$(CC) -DCA_LOG $(CFLAGS) $(INCLUDE) -c {0} -o {1}".format(name_cpp, name_debug_o))
        makefile.rule(name_mpi_o, [ name_cpp, "head.cpp" ],
            "$(MPICC) -DCA_MPI $(CFLAGS) $(INCLUDE) -c {0} -o {1}".format(name_cpp, name_mpi_o))
        makefile.rule(name_mpi_debug_o, [ name_cpp, "head.cpp" ],
            "$(MPICC) -DCA_MPI -DCA_LOG $(CFLAGS) $(INCLUDE) -c {0} -o {1}".format(name_cpp, name_mpi_debug_o))
        all = deps + [ name_o, name_mpi_o, name_debug_o, name_mpi_debug_o ]

        makefile.rule("clean", [],
            "rm -f {0} {0}_debug {0}_mpi {0}_mpidebug {1}".format(name," ".join(all)), phony = True)
        makefile.write_to_file(os.path.join(directory, "makefile"))



class CppLibGenerator(CppGenerator):

    def build(self, directory):

        if self.project.get_target_mode() == "lib":
            self.build_library(directory)
            self.write_library_makefile(directory)

        if self.project.get_target_mode() == "rpclib":
            self.build_server(directory)
            self.build_client_library(directory)
            self.write_client_library_makefile(directory)

        if self.project.get_target_mode() == "octave":
            self.build_library(directory)
            self.build_oct_files(directory)
            self.write_library_makefile(directory, octave = True)

    def build_client_library(self, directory):
        source_filename = os.path.join(directory, self.project.get_name() + ".cpp")
        header_filename = os.path.join(directory, self.project.get_name() + ".h")

        # Build .cpp
        builder = Builder(self.project, source_filename)
        builder.build_client_library(self.project.get_name() + ".h")
        builder.write_to_file()

        # Build .h
        builder = Builder(self.project, header_filename)
        builder.build_client_library_header_file()
        builder.write_to_file()


    def build_server(self, directory):
        server_directory = os.path.join(directory, "server")

        # Check for server directory
        if os.path.exists(server_directory):
            if not os.path.isdir(server_directory):
                raise base.utils.PtpException("'server' exists but it is not directory")
        else:
            os.makedirs(server_directory)

        # Copy head file
        shutil.copyfile(os.path.join(directory, "head.cpp"), os.path.join(server_directory, "head.cpp"))

        source_filename = os.path.join(server_directory, self.project.get_name() + "_server.cpp")

        builder = Builder(self.project, source_filename)
        builder.build_server()
        builder.write_to_file()

        self.write_server_makefile(server_directory)

    def build_library(self, directory):
        source_filename = os.path.join(directory, self.project.get_name() + ".cpp")
        header_filename = os.path.join(directory, self.project.get_name() + ".h")

        # Build .cpp
        builder = Builder(self.project, source_filename)
        builder.build_library(self.project.get_name() + ".h")
        builder.write_to_file()

        # Build .h
        builder = Builder(self.project, header_filename)
        builder.build_library_header_file()
        builder.write_to_file()

    def build_oct_files(self, directory):
        source_filename = os.path.join(directory, self.project.get_name() + "_oct.cpp")
        m_filename = os.path.join(directory, self.project.get_name() + ".m")

        builder = Builder(self.project, source_filename)
        builder.build_oct(self.project.get_name() + ".h")
        builder.write_to_file()

        builder = OctaveBuilder(self.project)
        builder.build_loader(self.project.get_name() + ".oct")
        builder.write_to_file(m_filename)

    def write_server_makefile(self, directory):
        makefile = self.prepare_makefile(libs=["caserver"],
                                         libdir=[paths.CASERVER_DIR],
                                         include=[paths.CASERVER_DIR])

        makefile.set("CASERVER_INCLUDE", "-I" + paths.CASERVER_DIR)
        makefile.set("CASERVER_LIBDIR", "-L" + paths.CASERVER_DIR)

        name = self.project.get_name() + "_server"
        name_o = name + ".o"
        other_deps = self.get_other_dependancies()
        deps = [ name_o ] + other_deps
        makefile.rule(name, deps, "$(CC) " + " ".join(deps) +
                " -o $@ $(CFLAGS) $(INCLUDE) $(LIBDIR) $(LIBS)" )
        makefile.rule("clean", [], "rm -f {0} {1}".format(name," ".join(deps)))
        makefile.write_to_file(os.path.join(directory, "makefile"))

    def write_library_makefile(self, directory, octave = False):

        makefile = self.prepare_makefile()
        other_deps = self.get_other_dependancies()

        name = self.project.get_name()
        name_o = name + ".o"
        libname_a = "lib{0}.a".format(name)

        targets = [ libname_a ]
        if octave:
            targets.append("octave")

        makefile.rule("all", targets, phony = True)

        if octave:
            name_oct = name + ".oct"
            name_oct_cpp = name + "_oct.cpp"
            makefile.rule("octave", [ name_oct ], phony = True)
            makefile.rule(name_oct, [ name_oct_cpp ], "mkoctfile $< $(INCLUDE) -o {0}".format(name_oct))

        deps = [ name_o ] + other_deps
        makefile.rule(libname_a, deps, "ar -cr lib{0}.a ".format(name) + " ".join(deps))

        all = deps + [ libname_a ]

        if octave:
            all.append(name_oct)

        makefile.rule("clean", [], "rm -f {0}".format(" ".join(all)), phony = True)
        makefile.write_to_file(os.path.join(directory, "makefile"))


    def write_client_library_makefile(self, directory):
        makefile = self.prepare_makefile()
        other_deps = self.get_other_dependancies()

        name = self.project.get_name()
        name_o = name + ".o"
        libname_a = "lib{0}.a".format(name)

        makefile.rule("all", [ libname_a, "server" ], phony = True)
        makefile.rule("server", [], "make -C server", phony = True)

        deps = [ name_o ] + other_deps
        makefile.rule(libname_a, deps, "ar -cr lib{0}.a ".format(name) + " ".join(deps))

        all = deps + [ libname_a ]

        makefile.rule("clean", [], "rm -f {0}".format(" ".join(all)))

        makefile.write_to_file(os.path.join(directory, "makefile"))
