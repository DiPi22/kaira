<project extenv="C++"><configuration><parameter default="10" description="" name="LIMIT" type="Int" /><parameter default="4" description="" name="SIZE_X" type="Int" /><parameter default="4" description="" name="SIZE_Y" type="Int" /><parameter default="200" description="" name="TEMP" type="Int" /><parameter default="5" description="" name="WORKERS" type="Int" /><extern-type name="Row" octave-value="False" raw-type="Row" transport-mode="Custom" type="native"><code name="getsize">	return ROW_DATA_SIZE;
</code><code name="unpack">	const double *data = (double *) unpacker.unpack(ROW_DATA_SIZE);
	return Row(data);
</code><code name="pack">	packer.pack(obj.get_raw_data(), ROW_DATA_SIZE);
</code></extern-type><extern-type name="Data" octave-value="False" raw-type="Data *" transport-mode="Custom" type="native"><code name="getsize">	return (ROW_DATA_SIZE * obj-&gt;get_size()) + sizeof(int);
</code><code name="unpack">	int t, size = unpacker.unpack_int();
	Data *d = new Data(0, size);
	for (t = 0; t &lt; size; t++)
	{
		d-&gt;set_raw_row(t, (double*) unpacker.unpack(ROW_DATA_SIZE));
	}
	return d;
</code><code name="pack">	int t, size = obj-&gt;get_size();
	packer.pack_int(size);
	for (t = 0; t &lt; size; t++) {
		packer.pack(obj-&gt;get_raw_row(t), ROW_DATA_SIZE);
	}
</code></extern-type><function id="0" name="to_up" parameters="" return-type="Int" with-context="True">	int count = ctx.process_count();
	return (ctx.process_id() + count - 1) % count;
</function><function id="0" name="to_down" parameters="" return-type="Int" with-context="True">	return (ctx.process_id() + 1) % ctx.process_count();
</function><build-option name="CC">g++</build-option><build-option name="LIBS" /><build-option name="CFLAGS">-O2</build-option><head-code>
#include &lt;sstream&gt;
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
#include &lt;iomanip&gt;

#define WIDTH parameter_SIZE_X()
#define ROW_DATA_SIZE (sizeof(double) * WIDTH)

int parameter_WORKERS();
int parameter_SIZE_Y();
int parameter_SIZE_X();
int parameter_TEMP();

class Row {
	
	public:

	Row() {
		array = new double[WIDTH];
	}

	Row(const double *data) {
		array = new double [WIDTH];
		set_raw_data(data);
	}

	~Row() {
		delete [] array;
	}

	Row(const Row &amp;c) {
		array = new double [WIDTH];
		set_raw_data(c.get_raw_data());
	}

	Row &amp; operator= (const Row &amp; c) {
        if (this != &amp;c)
		{
			set_raw_data(c.get_raw_data());
        }
        return *this;
	}


	const double * get_raw_data() const { return array; }
	void set_raw_data(const double *data) {
		memcpy(array, data, ROW_DATA_SIZE);
	}

	void set_zero() {
		int t;
		for (t = 0; t &lt; WIDTH; t++) {
			array[t] = 0.0;
		}
	}

	void dump() {
		int t;
		printf("Column: ");
		for (t = 0; t &lt; WIDTH; t++) {
			printf("%g ", array[t]);
		}
		printf("\n");
	}

	public:
		double *array;

};

class Data {
	public:
		Data(const int position, const int size) {
			this-&gt;size = size;
			this-&gt;position = position;
			array1 = new double[(size + 2) * (WIDTH + 2)];
			array2 = new double[(size + 2) * (WIDTH + 2)];
			init();
		}
		
		void init() {
			int t;
			for (t = (WIDTH + 2); t &lt; (size + 2) * (WIDTH + 2); t++) {
				array1[t] = 0.0;
			}
			set_fixed_temp();
		}

		double * get_raw_row(int i) const { return array1 + (i + 1) * (WIDTH + 2) + 1; };
		void set_raw_row(int i, const double *data) { memcpy(get_raw_row(i), data, ROW_DATA_SIZE); };		


		void set_fixed_temp()
		{
			int source_y = parameter_SIZE_Y() / 2;
			if (source_y &gt;= position &amp;&amp; source_y &lt; position + size) {
				source_y -= position;
				int source_x = parameter_SIZE_X() / 2;
				array1[ (source_y + 1) * (WIDTH + 2) + (source_x + 1) ] = parameter_TEMP();
			}
		}
		
		void compute(Row &amp;c1, Row &amp;c2)
		{
			set_raw_row(-1, c1.get_raw_data());
			set_raw_row(size, c2.get_raw_data());			
			int t, s;
			for (t = WIDTH + 2; t &lt; (size + 1) * (WIDTH + 2); t+=(WIDTH + 2)) {
				array1[t] = 0.0; // Zero values in left and right columns
				array1[t + WIDTH + 1] = 0.0;
				for (s = 1; s &lt;= WIDTH; s++) {
					int i = t + s;
					int u = i - (WIDTH + 2);
					int d = i + (WIDTH + 2); 
					int l = i - 1;
					int r = i + 1;
					array2[i] = (4.0 * array1[i] + array1[u] + array1[d] + array1[l] + array1[r]) / 8.0;
				}
			}
			double *a = array1;
			array1 = array2;
			array2 = a;
			set_fixed_temp();
			get_rows(c1, c2);
		}

		void get_rows(Row &amp;c1, Row &amp;c2) 
		{
			c1.set_raw_data(get_raw_row(0));
			c2.set_raw_data(get_raw_row(size -1));
		}

		std::string as_html() {
			std::stringstream stream;
			stream.precision(2);
			stream.setf(std::ios_base::fixed);
			for (int t = WIDTH + 2; t &lt; (size + 1) * (WIDTH + 2); t+=(WIDTH + 2)) {
				stream &lt;&lt; "&lt;tr&gt;" &lt;&lt; std::endl;
				for (int s = 1; s &lt;= WIDTH; s++) {
					int i = t + s;
					stream &lt;&lt; "&lt;td&gt;" &lt;&lt; array1[i] &lt;&lt; "&lt;td/&gt;" &lt;&lt; std::endl;
				}
				stream &lt;&lt; "&lt;/tr&gt;" &lt;&lt; std::endl;
			}
			return stream.str();
		}

		~Data() {
			delete [] array1;
			delete [] array2;
		}
		
		int get_size() const { return size; }

	protected:
		int size;
		int position;
		double *array1, *array2;
};

int id_to_position(int process_count, int iid)
{
	int rows_per_instance = ((parameter_SIZE_Y() - 1) / process_count) + 1;
	return rows_per_instance * iid;
}

int id_to_size(int process_count, int iid)
{
	int rows_per_instance = ((parameter_SIZE_Y() - 1) / process_count) + 1;
	int first = rows_per_instance * iid;
	int end = first + rows_per_instance;
	if (parameter_SIZE_Y() &lt; end) {
		end = parameter_SIZE_Y();
	}
	return end - first;
}</head-code></configuration><net id="101" name="Main" net-type="main"><place id="103" init_string="" place_type="Data" radius="20" x="70" y="285"><code>	int process_id = ctx.process_id();
	Data *data = new Data(id_to_position(ctx.process_count(), process_id), id_to_size(ctx.process_count(), process_id));
//	data-&gt;random_fill();
	tokens.push_back(data);
</code></place><place id="104" init_string="" place_type="(Int, Row)" radius="20" x="295" y="360" /><place id="105" init_string="" place_type="Data" radius="20" x="295" y="285" /><place id="106" init_string="" place_type="(Int, Row)" radius="20" x="295" y="210" /><place id="107" init_string="[0]" place_type="Int" radius="20" x="635" y="375" /><place id="108" init_string="" place_type="(Int, Data)" radius="22" x="830" y="285" /><transition guard="" id="109" name="Init" sx="70" sy="35" x="190" y="285"><code>	var.data-&gt;get_rows(var.up, var.down);
</code></transition><transition guard="c &lt; #LIMIT" id="110" name="Compute" sx="70" sy="35" x="520" y="285"><code>	if (ctx.process_id() == 0) {
		var.up.set_zero();
	}
	if (ctx.process_id() == ctx.process_count() - 1) {
		var.down.set_zero();
	}
	var.data-&gt;compute(var.up, var.down);
</code></transition><transition guard="" id="111" name="Send result" sx="70" sy="35" x="635" y="285" /><transition guard="" id="112" name="Write results" sx="70" sy="35" x="830" y="185"><code>	int t, size = var.results.size();
	std::string s[size];
	for (t=0; t &lt; size; t++) {
		s[var.results[t].t0] = var.results[t].t1-&gt;as_html();
		delete var.results[t].t1;
	}
	
	std::ofstream stream("result.html");
	stream &lt;&lt; "&lt;html&gt;&lt;head&gt;&lt;style type='text/css'&gt;table, tr, td { border: 1px solid; }&lt;/style&gt;";
	stream &lt;&lt; "&lt;/head&gt;&lt;table&gt;\n";
	for (t=0; t &lt; size; t++) {
		stream &lt;&lt; s[t] &lt;&lt; std::endl;
	}
	stream &lt;&lt; "&lt;/table&gt;&lt;/body&gt;&lt;/html&gt;\n";	
	stream.close();
	
	ctx.quit();
</code></transition><edge from_item="103" id="113" inscription="data" inscription_x="120.0" inscription_y="275.0" to_item="109" /><edge from_item="109" id="114" inscription="(0, up)@to_up()" inscription_x="223.0" inscription_y="370.0" to_item="104"><point x="190" y="360" /></edge><edge from_item="109" id="115" inscription="data" inscription_x="247.0" inscription_y="275.0" to_item="105" /><edge from_item="109" id="116" inscription="(0, down)@to_down()" inscription_x="220.0" inscription_y="190.0" to_item="106"><point x="190" y="210" /></edge><edge from_item="110" id="117" inscription="(c + 1, up)@to_up()" inscription_x="475.0" inscription_y="365.0" to_item="104"><point x="520" y="360" /></edge><edge bidirectional="true" from_item="105" id="118" inscription="data" inscription_x="395.0" inscription_y="275.0" to_item="110"><point x="380" y="285" /></edge><edge from_item="110" id="119" inscription="(c + 1, down)@to_down()" inscription_x="455.0" inscription_y="193.0" to_item="106"><point x="520" y="210" /></edge><edge from_item="106" id="121" inscription="(c, up)" inscription_x="365.0" inscription_y="240.0" to_item="110" /><edge from_item="107" id="122" inscription="c" inscription_x="595.0" inscription_y="325.0" to_item="110" /><edge from_item="108" id="123" inscription="~results(process_count())" inscription_x="760.0" inscription_y="227.0" to_item="112" /><edge from_item="107" id="124" inscription="#LIMIT" inscription_x="655.0" inscription_y="324.0" to_item="111" /><edge from_item="111" id="125" inscription="(process_id(), data)@0" inscription_x="740.0" inscription_y="270.0" to_item="108" /><edge from_item="105" id="126" inscription="data" inscription_x="625.0" inscription_y="195.0" to_item="111"><point x="635" y="210" /></edge><edge from_item="110" id="127" inscription="c+1" inscription_x="570.0" inscription_y="355.0" to_item="107"><point x="580" y="350" /></edge><edge from_item="104" id="129" inscription="(c, down)" inscription_x="435.0" inscription_y="330.0" to_item="110"><point x="420" y="325" /></edge><area id="102" init-expr="[0 .. process_count() - 1]" name="" sx="643" sy="273" x="35" y="143" /></net></project>